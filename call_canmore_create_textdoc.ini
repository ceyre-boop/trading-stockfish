{"title":"STOCKFISH FOR TRADING — PRINCIPLES, MAPPING, AND IMPLEMENTATIONREFERENCE","body":"# STOCKFISH FOR TRADING — PRINCIPLES, MAPPING, AND IMPLEMENTATION REFERENCE\n\nThis document is the canonical design and implementation reference that maps Stockfish chess concepts to a production‑grade trading engine. Save this file in the repository (e.g., docs/STOCKFISH_ANALOGY.md) and use it as the single source of truth for architecture, module responsibilities, deterministic rules, and evaluation protocols. Copilot and other assistants should consult this file before making changes.\n\n---\n\n## OVERVIEW\n\nGoal: Build a deterministic, replayable, explainable, and institution‑grade trading engine using the same engineering discipline as Stockfish: state → evaluation → policy → execution → governance → benchmarking.\n\nCore principles:\n- Determinism: Every run with the same inputs must produce identical outputs. No hidden randomness.\n- Replay safety: Live and historical pipelines must be identical in logic and outputs.\n- Factorization: Evaluation is decomposed into named factors that are testable and ablatable.\n- Microstructure awareness: Order flow, liquidity, and execution realism are first‑class features.\n- Regime awareness: Decisions are conditioned on volatility/liquidity/macro regimes.\n- Scientific benchmarking: Use Trading ELO, scenario libraries, and reproducible tournaments.\n\n---\n\n## 1. DIRECT MAPPING: CHESS → TRADING\n\n| Chess Concept | Trading Equivalent | Purpose / Implementation Notes |\n|---|---:|---|\n| Board state | MarketState dataclass | Canonical, immutable snapshot containing price, order flow, liquidity, volatility, macro, and execution context. All modules consume this. |\n| Evaluation (centipawns) | Eval score (signed scalar) + confidence + factor breakdown | Factorized scoring: trend, order flow, liquidity, volatility, macro. Deterministic, JSON serializable. |\n| Move generation | Candidate actions (policy proposals) | Discrete action set: FLAT, ENTER_LONG, ENTER_SHORT, ADD, REDUCE, EXIT. Policy engine generates candidate actions with expected utility. |\n| Search (minimax, alpha‑beta) | Scenario simulation / policy evaluation | Simulate execution paths (deterministic simulator) under different fills, slippage, and regime transitions. Use pruning by confidence and cost. |\n| Opening book | Playbook / regime playbook | Predefined strategies for known regimes (e.g., high‑liquidity trend day). Stored, versioned, and testable. |\n| Endgame tablebases | Risk tablebases / forced rules | Hard rules for forced de‑risking: e.g., if drawdown > X or liquidity shock occurs, always exit. Deterministic and audited. |\n| Tactics & tactics search | Short‑horizon microstructure tactics | Sweep detection, liquidity sweep responses, opportunistic fills. Fast, deterministic micro‑routines. |\n| Engine tournaments | Trading ELO tournaments | Run engine versions across scenario libraries and historical periods to compute ELO and robustness metrics. |\n\n---\n\n## 2. CANONICAL MARKETSTATE (SOURCE OF TRUTH)\n\nDefine a single MarketState dataclass used across the codebase. Example schema (Python dataclass):\n\npython\nfrom dataclasses import dataclass\nfrom typing import Dict, Any, Optional\n\n@dataclass(frozen=True)\nclass PriceState:\n timestamp: str\n mid: float\n bid: float\n ask: float\n spread: float\n candles: Dict[str, Any] # multi-TF candles\n\n@dataclass(frozen=True)\nclass OrderFlowState:\n aggressive_buy_volume: float\n aggressive_sell_volume: float\n net_imbalance: float\n sweep_flag: bool\n quote_pulling_score: float\n\n@dataclass(frozen=True)\nclass LiquidityState:\n top_depth_bid: float\n top_depth_ask: float\n cumulative_depth_bid: float\n cumulative_depth_ask: float\n depth_imbalance: float\n liquidity_resilience: float\n liquidity_pressure: float\n liquidity_shock: bool\n\n@dataclass(frozen=True)\nclass VolatilityState:\n realized_vol: float\n intraday_band_width: float\n vol_of_vol: float\n vol_regime: str # LOW, NORMAL, HIGH, EXTREME\n\n@dataclass(frozen=True)\nclass MacroNewsState:\n hawkishness: float\n risk_sentiment: float\n surprise_score: float\n macro_regime: str\n\n@dataclass(frozen=True)\nclass ExecutionContext:\n position_size: float\n avg_entry_price: Optional[float]\n unrealized_pnl: float\n realized_pnl: float\n\n@dataclass(frozen=True)\nclass MarketState:\n price: PriceState\n order_flow: OrderFlowState\n liquidity: LiquidityState\n volatility: VolatilityState\n macro: MacroNewsState\n execution: ExecutionContext\n raw: Dict[str, Any]\n\n\nRules:\n- All fields must have neutral defaults when data is missing.\n- MarketState must be serializable and immutable (frozen dataclasses preferred).\n- Timestamps must be timezone‑aware and validated for causality.\n\n---\n\n## 3. EVALUATION: FACTORIZED, CAUSAL, EXPLAINABLE\n\nEvaluator outputs:\n- score: float in [-1.0, 1.0] (signed expected edge normalized)\n- confidence: float in [0.0, 1.0]\n- factors: dict of named factor scores and weights\n- explain: structured breakdown for auditing\n\nFactor examples and formulas (deterministic):\n- Trend factor: normalized slope of multi‑TF EMA; scaled by volatility regime.\n- Order flow factor: normalized net aggressive volume over lookback / total volume.\n- Liquidity factor: depth imbalance and resilience; penalize thin books.\n- Volatility factor: realized vol vs historical; scale position sizing.\n- Macro factor: hawkishness * event_importance.\n\nImplementation notes:\n- Each factor is a pure function factor(state) -> (score, confidence_component).\n- Final score = sum(weight_i * score_i); confidence = weighted_variance_of_factors.\n- Factor weights are tunable and regime‑dependent.\n\n---\n\n## 4. POLICY ENGINE: FROM SCORE TO ACTION\n\nAction set: ['FLAT','ENTER_LONG','ENTER_SHORT','ADD','REDUCE','EXIT']\n\nPolicy logic:\n1. Map score and confidence to a target position size using a deterministic sizing function (see Risk Engine).\n2. Apply regime filters: if vol_regime == EXTREME reduce aggression; if liquidity_shock then exit.\n3. Generate discrete order plan: limit vs market, size, price, time‑in‑force.\n4. Return PolicyDecision object with deterministic metadata.\n\nPolicy pseudocode:\n\npython\nif state.liquidity.liquidity_shock:\n action = 'EXIT'\nelif abs(score) < score_threshold:\n action = 'FLAT'\nelse:\n side = 'LONG' if score > 0 else 'SHORT'\n size = risk_engine.size_for_score(score, confidence, state)\n action = 'ENTER_LONG' if side == 'LONG' else 'ENTER_SHORT'\n\n\nNotes:\n- Policy must never directly execute; it returns a plan consumed by execution layer.\n- Policy decisions are versioned and auditable.\n\n---\n\n## 5. EXECUTION: SIMULATOR + LIVE BRIDGE\n\nTwo interchangeable backends:\n- ExecutionSimulator (deterministic, liquidity‑aware) — used for backtest and policy evaluation.\n- MT5Execution (live) — strict safety checks, demo mode, non‑blocking.\n\nExecutionResult dataclass (canonical):\n\npython\n@dataclass\nclass ExecutionResult:\n side: str\n requested_size: float\n filled_size: float\n fill_price: float\n slippage: float\n transaction_cost: float\n fills: List[Dict[str, Any]]\n raw_state: Optional[Dict[str, Any]] = None\n\n\nSimulator rules:\n- Use liquidity.cumulative_depth to cap fills.\n- Slippage = base_slippage + k1(1/top_depth) + k2liquidity_pressure + k3shock_flag.\n- Partial fills allowed; deterministic fill order (e.g., FIFO by aggressor volume).\n- All local variables must be initialized with safe defaults.\n\nLive rules:\n- In demo mode, never call blocking connect or retry loops.\n- All live orders pass through governance checks before submission.\n\n---\n\n## 6. RISK & GOVERNANCE (THE KING PROTECTION)\n\nPrimary objective:* prevent ruin and enforce institutional constraints.\n\nCore rules:\n- Max exposure per instrument (configurable). If exceeded, veto new entries.\n- Max portfolio drawdown (hard stop). If exceeded, enter emergency exit mode.\n- Max trades per hour to avoid overtrading.\n- Stale data veto: if state timestamp is older than threshold, pause trading.\n- Kill switch: manual and automated triggers.\n\nRisk sizing:\n- Use volatility‑adjusted sizing: size = base_risk / (volatility * price).\n- Cap size by liquidity: size = min(size, cumulative_depth * liquidity_safety_factor).\n\nGovernanceEngine:\n- Receives PolicyDecision and MarketState, returns ExecutionPlan or veto.\n- Logs every veto with reason and state snapshot.\n\n---\n\n## 7. REGIME ENGINE (v4.0‑D) — WEATHER SYSTEM\n\nRegimes to classify:\n- Volatility regime: LOW, NORMAL, HIGH, EXTREME\n- Liquidity regime: DEEP, NORMAL, THIN, FRAGILE\n- Macro regime: RISK_ON, RISK_OFF, EVENT\n\nRegime classifier inputs:\n- realized volatility, vol_of_vol, intraday band width\n- liquidity resilience and shock frequency\n- macro surprise and event importance\n\nRegime outputs:\n- regime tags and a regime confidence score\n- regime history (for transitions and hysteresis)\n\nUse: factor weights and policy thresholds are conditional on regime.\n\n---\n\n## 8. BENCHMARKING & TRADING ELO\n\nTournament harness:\n- Run multiple engine versions across a scenario library.\n- Each match: same historical period, same seeds, deterministic simulator.\n- Score by risk‑adjusted returns (Sharpe, Sortino), execution quality, and survival.\n\nELO design:\n- Use pairwise comparisons: version A vs B on the same scenario → winner determined by composite metric.\n- Update ELO using standard formula; maintain per‑instrument and per‑regime ELOs.\n\nScenario library:\n- Flash crash days, low liquidity sessions, macro event days, trend days, chop days.\n- Each scenario includes: historical ticks, order book snapshots, and news events.\n\n---\n\n## 9. INSTRUMENT‑SPECIFIC CALIBRATION (ES, NQ, XAU, XAG, FX)\n\nPer‑instrument profile:\n- tick_size, typical_spread, typical_depth, trading_hours, volatility_baseline\n- microstructure idiosyncrasies (e.g., ES vs NQ liquidity patterns)\n\nCalibration steps:\n1. Collect representative days for each instrument across regimes.\n2. Compute baseline metrics: median spread, median top_depth, median realized vol.\n3. Set default parameters: cumulative_depth_levels=5, liquidity_safety_factor=0.5, base_slippage.\n4. Tune factor weights per instrument using ELO tournaments.\n\nCross‑instrument policy: same architecture, different parameters and risk caps.\n\n---\n\n## 10. PLAYBOOKS, OPENING BOOKS, AND TABLEBASES\n\nPlaybooks:\n- Predefined strategies for common regimes (e.g., trend day breakout, mean reversion in low vol).\n- Stored as versioned JSON with deterministic rules and thresholds.\n\nTablebases (risk rules):\n- Hard, audited rules for forced exits and emergency behavior.\n- Example: if liquidity_shock and unrealized_pnl < -0.5% of NAV → immediate exit.\n\n---\n\n## 11. RESEARCH COCKPIT & REPLAY\n\nReplay engine:\n- Reconstruct MarketState sequence from historical ticks and order book snapshots.\n- Allow overlays: eval score, regime, liquidity, fills, PnL.\n\nCockpit features:\n- Step through time, inspect factor contributions, and replay execution decisions.\n- Export scenario reports for tournaments.\n\n---\n\n## 12. TESTING & VALIDATION\n\nEvery module must include:\n- Unit tests for pure functions and dataclass alignment.\n- Integration tests for module interactions (state → evaluator → policy → execution simulator).\n- Determinism tests: repeated runs with same inputs produce identical outputs.\n- Time‑causality tests: future timestamps rejected in official mode.\n\nCI rules:\n- Demo mode must be non‑blocking and fast.\n- No external network calls in unit tests.\n\n---\n\n## 13. OPERATIONAL RULES (DAILY SURVIVAL)\n\nDaily survival checklist:\n- Governance health check at start of day.\n- Scenario preflight: run a short replay of last N minutes to validate feeds.\n- Kill switch test in demo mode.\n- Logging and snapshot retention policy.\n\nPerformance monitoring:\n- Execution quality metrics: realized slippage vs simulated slippage.\n- Latency metrics for live execution.\n- PnL and drawdown dashboards.\n\n---\n\n## 14. IMPLEMENTATION GUIDELINES FOR COPILOT\n\nWhen Copilot edits code, follow these constraints:\n- Always consult docs/STOCKFISH_ANALOGY.md before changes.\n- Do not introduce randomness or non‑deterministic libraries.\n- Keep dataclasses aligned with usage; update tests if the dataclass is canonical.\n- Avoid global state; prefer immutable dataclasses and pure functions.\n- Use explicit versioning for playbooks and policy rules.\n\n---\n\n## 15. EXAMPLES & SNIPPETS\n\nDeterministic factor function example:\n\npython\ndef trend_factor(state: MarketState, lookback=20) -> Tuple[float, float]:\n # returns (score, confidence_component)\n prices = state.price.candles['1m'][-lookback:]\n slope = (prices[-1] - prices[0]) / lookback\n vol = state.volatility.realized_vol or 1.0\n score = clamp(slope / (vol * 0.001), -1.0, 1.0)\n confidence = min(1.0, abs(slope) / (0.0001 + vol))\n return score, confidence\n\n\nPolicy sizing snippet:\n\npython\ndef size_for_score(score, confidence, state, base_risk=0.001):\n vol = max(state.volatility.realized_vol, 1e-6)\n raw = base_risk * (score * confidence)\n price = state.price.mid\n size = abs(raw) / (vol * price)\n size = min(size, state.liquidity.cumulative_depth_bid * 0.5)\n return size\n\n\n---\n\n## 16. FINAL NOTES — WHAT \"CAPTURE THE KING\" MEANS HERE\n\n- There is no guaranteed daily profit. Markets are not deterministic games with terminal states.\n- The objective is survival + positive edge: avoid ruin, adapt to regimes, and improve via tournaments.\n- \"Capture the king\" in trading is analogous to eliminating catastrophic failure modes and ensuring the engine can consistently extract positive, risk‑adjusted returns across regimes.\n\n---\n\n## 17. NEXT ACTIONS (PRIORITIZED)\n\n1. Add docs/STOCKFISH_ANALOGY.md to repo and make it required reading for Copilot edits.\n2. Lock the canonical MarketState dataclasses in state/schema.py and update all modules to import from there.\n3. Implement RegimeEngine (v4.0‑D) and wire regime conditioning into evaluator and policy.\n4. Build scenario library and run initial ELO tournaments for ES and NQ.\n\n---\n\nThis file is the authoritative mapping between chess engine concepts and the trading engine. Use it for design decisions, code reviews, and automated assistant prompts. It must be kept up to date as the engine evolves."}